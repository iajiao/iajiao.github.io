# .github/workflows/notion-sync.yml
name: Notionè¶…é€ŸåŒæ­¥
on:
  schedule:
    - cron: "0 12 * * *"  # æ¯å¤©UTCæ—¶é—´12ç‚¹è‡ªåŠ¨åŒæ­¥
  workflow_dispatch:       # æ”¯æŒæ‰‹åŠ¨è§¦å‘

jobs:
  hyper-sync:
    runs-on: ubuntu-latest
    steps:
      # ========== åˆå§‹åŒ– ==========
      - name: æ£€å‡ºä»£ç 
        uses: actions/checkout@v4

      - name: è·å–ä¸Šæ¬¡åŒæ­¥æ—¶é—´
        id: get-time
        run: |
          echo "time=$(date -u -d '1 hour ago' +'%Y-%m-%dT%H:%M:%SZ')" >> $GITHUB_OUTPUT

      # ========== ä¾èµ–ç®¡ç† ==========
      - name: ç¼“å­˜åŠ é€Ÿ
        uses: actions/cache@v3
        with:
          path: |
            ~/.cache/pip
            vendor/bundle
          key: ${{ runner.os }}-${{ hashFiles('**/Gemfile.lock') }}-${{ hashFiles('requirements.txt') }}

      - name: å®‰è£…Pythonç¯å¢ƒ
        uses: actions/setup-python@v4
        with:
          python-version: "3.10"

      - name: å®‰è£…ä¾èµ–
        run: |
          pip install \
            notion-client==2.2.0 \
            python-frontmatter==1.0.0 \
            requests==2.31.0 \
            --index-url https://pypi.tuna.tsinghua.edu.cn/simple

      # ========== æ ¸å¿ƒåŒæ­¥é€»è¾‘ ==========
      - name: æ‰§è¡Œæ™ºèƒ½åŒæ­¥
        env:
          NOTION_TOKEN: ${{ secrets.NOTION_TOKEN }}
          NOTION_DATABASE_ID: ${{ secrets.NOTION_DATABASE_ID }}
          LAST_SYNC_TIME: ${{ steps.get-time.outputs.time }}
        run: |
          cat << 'EOF' > notion_hyper_sync.py
          import os
          import logging
          import requests
          from datetime import datetime
          from notion_client import Client
          import frontmatter
          from concurrent.futures import ThreadPoolExecutor

          # é…ç½®æ—¥å¿—
          logging.basicConfig(level=logging.INFO)
          logger = logging.getLogger(__name__)

          # ====== å¹¶è¡Œä¸‹è½½å™¨ ======
          class FastDownloader:
              def __init__(self, max_workers=5):
                  self.executor = ThreadPoolExecutor(max_workers=max_workers)

              def download(self, url, path):
                  try:
                      response = requests.get(url, timeout=10)
                      with open(path, 'wb') as f:
                          f.write(response.content)
                      return True
                  except Exception as e:
                      logger.error(f"ä¸‹è½½å¤±è´¥ {url}: {str(e)}")
                      return False

          # ====== Notionè§£æå¼•æ“ ======
          class NotionParser:
              def __init__(self, notion_client):
                  self.notion = notion_client

              def get_updated_pages(self, database_id, last_sync):
                  query = {
                      "filter": {
                          "and": [
                              {"property": "Status", "select": {"equals": "Published"}},
                              {"timestamp": "last_edited_time", "last_edited_time": {"after": last_sync}}
                          ]
                      }
                  }
                  return self.notion.databases.query(database_id,**query).get("results", [])

              def parse_content(self, page_id):
                  blocks = []
                  result = self.notion.blocks.children.list(block_id=page_id)
                  while True:
                      blocks.extend(result.get("results", []))
                      if not result.get("has_more"):
                          break
                      result = self.notion.blocks.children.list(
                          block_id=page_id,
                          start_cursor=result.get("next_cursor")
                      )
                  return "\n".join([self._parse_block(b) for b in blocks])

              def _parse_block(self, block):
                  type_ = block["type"]
                  content = block.get(type_, {})
                  
                  # æ–‡æœ¬å¤„ç†
                  if "rich_text" in content and content["rich_text"]:
                      text = "".join([t["plain_text"] for t in content["rich_text"]])
                      return {
                          "heading_1": f"# {text}",
                          "heading_2": f"## {text}",
                          "paragraph": text,
                          "bulleted_list_item": f"- {text}",
                          "numbered_list_item": f"1. {text}"
                      }.get(type_, "")
                  
                  # å›¾ç‰‡å¤„ç†
                  elif type_ == "image":
                      return f"![]({content.get('external', {}).get('url', '')})"
                  
                  return ""

          # ====== æ–‡ä»¶ç®¡ç†ç³»ç»Ÿ ======
          class FileManager:
              @staticmethod
              def cleanup_orphans(current_ids):
                  deleted = 0
                  for filename in os.listdir("_posts"):
                      if not filename.endswith(".md"):
                          continue
                      with open(f"_posts/{filename}", "r", encoding="utf-8") as f:
                          post = frontmatter.load(f)
                          if (page_id := post.get("notion_id")) and page_id not in current_ids:
                              os.remove(f"_posts/{filename}")
                              deleted += 1
                  logger.info(f"æ¸…ç†å®Œæˆ: åˆ é™¤ {deleted} ç¯‡æ—§æ–‡ç« ")

              @staticmethod
              def save_post(post_data, content):
                  post = frontmatter.Post(content)
                  post.metadata.update({
                      "layout": "post",
                      "notion_id": post_data["id"],
                      "title": post_data["title"],
                      "subtitle": post_data.get("subtitle", ""),
                      "date": post_data["date"],
                      "author": post_data["author"],
                      "header-img": post_data["header_img"],
                      "catalog": "true",
                      "tags": post_data["tags"]
                  })
                  filename = f"_posts/{post_data['date']}-{post_data['slug']}.md"
                  with open(filename, "w", encoding="utf-8", errors="replace") as f:
                      f.write(frontmatter.dumps(post))
                  return filename

          # ====== ä¸»æ§åˆ¶å™¨ ======
          def main():
              notion = Client(auth=os.environ["NOTION_TOKEN"])
              parser = NotionParser(notion)
              downloader = FastDownloader()
              fm = FileManager()

              # è·å–å¢é‡æ›´æ–°
              pages = parser.get_updated_pages(
                  os.environ["NOTION_DATABASE_ID"],
                  os.environ["LAST_SYNC_TIME"]
              )
              current_ids = [p["id"] for p in pages]

              # æ¸…ç†æ—§æ•°æ®
              fm.cleanup_orphans(current_ids)

              # å¤„ç†æ–°å†…å®¹
              for page in pages:
                  try:
                      props = page["properties"]
                      post_data = {
                          "id": page["id"],
                          "title": props["Title"]["title"][0]["plain_text"].strip(),
                          "slug": props["Slug"]["rich_text"][0]["plain_text"].strip(),
                          "date": props["Date"]["date"]["start"].split("T")[0],
                          "author": props["Author"]["rich_text"][0]["plain_text"].strip(),
                          "header_img": props["Header-img"]["rich_text"][0]["plain_text"].strip(),
                          "tags": [tag["name"] for tag in props["Tags"]["multi_select"]],
                          "subtitle": props.get("Subtitle", {}).get("rich_text", [{}])[0].get("plain_text", "")
                      }
                      
                      # ç”Ÿæˆå†…å®¹
                      content = parser.parse_content(page["id"])
                      filename = fm.save_post(post_data, content)
                      logger.info(f"ğŸ”¥ å·²åŒæ­¥: {filename}")

                  except Exception as e:
                      logger.error(f"âŒ å¤„ç†å¤±è´¥: {str(e)}")

          if __name__ == "__main__":
              main()
          EOF

          # æ‰§è¡Œè¶…é€ŸåŒæ­¥
          python notion_hyper_sync.py

      # ========== æé€Ÿæ„å»ºéƒ¨ç½² ==========
      - name: é—ªç”µæ„å»º
        uses: docker://jekyll/jekyll
        env:
          LANG: C.UTF-8
          JEKYLL_ENV: production
        with:
          args: jekyll build -d ./_site --limit_posts 10 --incremental

      - name: éƒ¨ç½²åˆ°Cloudflare
        uses: cloudflare/pages-action@1
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          projectName: "YOUR_PROJECT"
          directory: "./_site"
          commitMessage: "ğŸš€ è‡ªåŠ¨åŒæ­¥: ${{ github.run_id }}"
